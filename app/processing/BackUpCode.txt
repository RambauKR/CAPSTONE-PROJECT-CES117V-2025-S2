import cv2
from ultralytics import YOLO
from collections import defaultdict, deque
import numpy as np
import csv
import os
from datetime import datetime

class Group03Processor:
    # Load YOLO model
    model = YOLO("yolo11x.pt")

    # Store track history for movement direction
    track_history = defaultdict(lambda: deque(maxlen=30))

    # COCO vehicle classes
    vehicle_classes = [2, 3, 5, 7]  # Car, Motorcycle, Bus, Truck

    # Define custom lane polygons for 1920x1080
    lane_regions = {
        # Left carriageway (moving away from camera)
        "lane_1": [(500, 300), (750, 300), (260, 650), (0, 650)],    # leftmost
        "lane_2": [(750, 300), (820, 300), (500, 650), (260, 650)],
        "lane_3": [(820, 300), (880, 300), (800, 650), (500, 650)],  # next to median

        # Right carriageway (moving toward camera)
        "lane_4": [(970, 300), (1030, 300), (1300, 650), (1100, 650)],  # next to median
        "lane_5": [(1030, 300), (1080, 300), (1500, 650), (1300, 650)],
        "lane_6": [(1080, 300), (1200, 300), (1800, 650), (1500, 650)], # rightmost
    }

    # Dictionaries to store lane-wise IN and OUT counts
    lane_counts_in = defaultdict(lambda: defaultdict(int))
    lane_counts_out = defaultdict(lambda: defaultdict(int))
    counted_ids_in = set()
    counted_ids_out = set()

    # CSV setup
    csv_path = "vehicle_counts.csv"
    if not os.path.exists(csv_path):
        with open(csv_path, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["timestamp", "lane", "vehicle_type", "direction", "count"])

    @staticmethod
    def log_vehicle(lane, vehicle_type, direction, count):
        """Log detected vehicle counts to CSV file."""
        with open(Group03Processor.csv_path, "a", newline="") as f:
            writer = csv.writer(f)
            writer.writerow([
                datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                lane,
                vehicle_type,
                direction,
                count
            ])

    @staticmethod
    def point_in_polygon(point, polygon):
        x, y = point
        return cv2.pointPolygonTest(np.array(polygon, np.int32), (x, y), False) >= 0


    @staticmethod
    def process(frame):
        """Main vehicle detection and lane counting logic."""
        try:
            # Run YOLOv8 tracking
            results = Group03Processor.model.track(
                frame, persist=True, classes=Group03Processor.vehicle_classes,
                tracker="bytetrack.yaml", verbose=False
            )

            annotated_frame = frame.copy()

            if results[0].boxes is not None and results[0].boxes.id is not None:
                boxes = results[0].boxes.xywh.cpu()
                track_ids = results[0].boxes.id.int().cpu().tolist()
                class_ids = results[0].boxes.cls.int().cpu().tolist()

                for box, track_id, class_id in zip(boxes, track_ids, class_ids):
                    x, y, w, h = box
                    center_x, center_y = int(x), int(y)

                    

                    # Update tracking history
                    Group03Processor.track_history[track_id].append(center_y)

                    # Determine which lane the vehicle is in
                    lane_name = None
                    for lane, polygon in Group03Processor.lane_regions.items():
                        if Group03Processor.point_in_polygon((center_x, center_y), polygon):
                            lane_name = lane
                            # Draw detection center and ID
                            cv2.circle(annotated_frame, (center_x, center_y), 5, (0, 0, 255), -1)
                            cv2.putText(
                                annotated_frame,
                                f"{track_id}",
                                (center_x + 20, center_y),
                                cv2.FONT_HERSHEY_SIMPLEX,
                                0.7,
                                (0, 255, 0),
                                2,
                            )
                            break
                    if lane_name is None:
                        continue

                    # Assign direction based on lane position (no midline check needed)
                    in_lanes = ["lane_1", "lane_2", "lane_3"]   # vehicles moving away from camera
                    out_lanes = ["lane_4", "lane_5", "lane_6"]  # vehicles moving toward camera

                    if lane_name in in_lanes:
                        direction = "IN"
                        if track_id not in Group03Processor.counted_ids_in:
                            Group03Processor.lane_counts_in[lane_name][class_id] += 1
                            Group03Processor.counted_ids_in.add(track_id)
                            Group03Processor.log_vehicle(
                                lane_name,
                                Group03Processor.get_class_name(class_id),
                                direction,
                                Group03Processor.lane_counts_in[lane_name][class_id]
                            )

                    elif lane_name in out_lanes:
                        direction = "OUT"
                        if track_id not in Group03Processor.counted_ids_out:
                            Group03Processor.lane_counts_out[lane_name][class_id] += 1
                            Group03Processor.counted_ids_out.add(track_id)
                            Group03Processor.log_vehicle(
                                lane_name,
                                Group03Processor.get_class_name(class_id),
                                direction,
                                Group03Processor.lane_counts_out[lane_name][class_id]
                            )


            # Draw lane boundaries and labels
            for lane, polygon in Group03Processor.lane_regions.items():
                pts = np.array(polygon, np.int32).reshape((-1, 1, 2))
                cv2.polylines(annotated_frame, [pts], True, (255, 255, 0), 2)

                # IN counts (left side of lane)
                x_in = min([p[0] for p in polygon]) + 20
                y_offset = 50
                for class_id, count in Group03Processor.lane_counts_in[lane].items():
                    cv2.putText(
                        annotated_frame,
                        f"{lane} IN {Group03Processor.get_class_name(class_id)}:{count}",
                        (x_in, y_offset),
                        cv2.FONT_HERSHEY_SIMPLEX,
                        0.7,
                        (0, 255, 0),
                        2,
                    )
                    y_offset += 40

                # OUT counts (right side of lane)
                x_out = max([p[0] for p in polygon]) - 300
                y_offset = 50
                for class_id, count in Group03Processor.lane_counts_out[lane].items():
                    cv2.putText(
                        annotated_frame,
                        f"{lane} OUT {Group03Processor.get_class_name(class_id)}:{count}",
                        (x_out, y_offset),
                        cv2.FONT_HERSHEY_SIMPLEX,
                        0.7,
                        (0, 0, 255),
                        2,
                    )
                    y_offset += 40

            return annotated_frame

        except Exception as e:
            print(f"Error in Group03Processor: {e}")
            return frame

    @staticmethod
    def get_class_name(class_id):
        """Return human-readable class names."""
        class_names = {2: "Car", 3: "Motorcycle", 5: "Bus", 7: "Truck"}
        return class_names.get(class_id, f"Class {class_id}")
